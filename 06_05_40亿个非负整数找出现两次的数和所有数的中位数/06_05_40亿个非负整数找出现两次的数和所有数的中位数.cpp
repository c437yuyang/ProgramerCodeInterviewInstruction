/*
40亿个非负整数找出现两次的数和所有数的中位数



找出现两次的数:
内存限制:1GB

直接遍历:8B*4G = 32G内存，不行
解决:申请大小为UINT_MAX*2的bitarray,就是每个数对应两位
遍历，出现第一次，设置为01，第二次10，第三次和以后11，最后找01的即可。
用到:UINT_MAX*2/8 = 1GB空间


找所有数的中位数:(直接partition在数据量很大的情况下也是不错的)
10MB内存限制，申请8MB = 2M * 4，spanCount[2M]
SPAN = UINT_MAX/2M,每个区域也是2M个数
分2M个区域进行统计，然后进行累加，看20亿出现在累加和的哪个位置即可确定区间。


记下区间开始的累加和，然后再遍历所有数做词频统计Count[2M]，只看前面找到区间的
最后再次做累加，找到位置在20亿的值即可。
*/

/*
初步总结:
如果只看出现指定次数的，那么可以用bitarray来解决。
如果出现次数不限，那么就要用分流来解决了

找没出现的，和中位数，用分区间统计

*/