/*
40亿非负整数中找到所有没出现的非负整数

内存限制 1GB

40亿 = 4G

UINT_MAX = 4294967295

32位无符号整数可以完全覆盖

如果用哈希表，那么set<unsigned int>可以做到，但是需要内存:4G*4B = 16GB 内存

解决方法:
申请一个长度为UINT_MAX的BitArray,只需要近500M空间(用int数组模拟实现可以)
然后遍历，出现了就把这个位置1，最后看哪一个位没出现就可以了


进阶: 内存限制在10MB内，但是只用找到一个没有出现过的数即可

解决方法:
SPAN = UINT_MAX / 64 = 67108864
先进行区间统计int span_count[64]，统计64个区间(均分 0-> UINT_MAX),遍历每个数Cur，用Cur/SPAN看在哪个区间

然后看哪个区间的数少于SPAN(因为只有40亿个数，那么肯定有区间不满)
然后申请一个BitArray[SPAN] 大约8MB空间
然后再遍历所有数，只看在这个区间内的数，然后遍历，看哪个位不是1就行了。

*/